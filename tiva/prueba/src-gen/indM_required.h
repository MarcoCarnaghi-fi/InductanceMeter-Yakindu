/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef INDM_REQUIRED_H_
#define INDM_REQUIRED_H_

#include "..\src\sc_types.h"
#include "indM.h"

#ifdef __cplusplus
extern "C"
{
#endif 

/*! \file This header defines prototypes for all functions that are required by the state machine implementation.

This is a state machine uses time events which require access to a timing service. Thus the function prototypes:
	- indM_set_timer and
	- indM_unset_timer
are defined.

This state machine makes use of operations declared in the state machines interface or internal scopes. Thus the function prototypes:
	- indM_port_configuration
	- indM_control_and_RCalculation
	- indM_res_Closing
	- indM_res_Init
	- indM_set_Time_Reference
	- indM_setting
	- indM_safe_Close
	- indM_normal_Close
	- indM_data_Processing
	- indM_uART_routine
	- indM_get_Data
	- indM_get_Data_Array
	- indM_systick_Conf
	- indM_handler_Disable
are defined.

These functions will be called during a 'run to completion step' (runCycle) of the statechart. 
There are some constraints that have to be considered for the implementation of these functions:
	- never call the statechart API functions from within these functions.
	- make sure that the execution time is as short as possible.
 
*/
extern sc_boolean indM_port_configuration(const IndM* handle);

//extern void indM_control_and_RCalculation(const IndM* handle, const sc_real sp_Vref, const sc_real sp_v_gate, const sc_integer sp_data, const sc_real sp_R);
extern void indM_control_and_RCalculation(const IndM* handle, const sc_real* sp_Vref, const sc_real* sp_v_gate, const sc_integer* sp_data, const sc_real* sp_R);

//extern sc_boolean indM_res_Closing(const IndM* handle);
extern sc_boolean indM_res_Closing(const IndM* handle, const sc_real* sp_v_gate);

//extern sc_boolean indM_res_Init(const IndM* handle, const sc_real sp_Vref, const sc_real sp_v_gate, const sc_integer sp_data);
extern sc_boolean indM_res_Init(const IndM* handle, const sc_real* sp_Vref, const sc_real* sp_v_gate, const sc_integer* sp_data);

extern void indM_set_Time_Reference(const IndM* handle, const sc_integer ni);

extern void indM_setting(const IndM* handle, const sc_boolean gain_set, const sc_boolean f_ireach, const sc_boolean WrongSetting);

extern sc_boolean indM_safe_Close(const IndM* handle);

extern sc_boolean indM_normal_Close(const IndM* handle, const sc_integer ni, const sc_integer nf);

//extern sc_boolean indM_data_Processing(const IndM* handle,const sc_string sp_bf,const sc_string sp_bf_i);
extern sc_boolean indM_data_Processing(const IndM* handle);
//extern void indM_uART_routine(const IndM* handle, const sc_string sp_bf,const sc_string sp_bf_i);
extern void indM_uART_routine(const IndM* handle);
extern void indM_get_Data(const IndM* handle);
extern void indM_get_Data_Array(const IndM* handle);
extern void indM_systick_Conf(const IndM* handle, const sc_integer period);
extern void indM_handler_Disable(const IndM* handle);



/*!
 * This is a timed state machine that requires timer services
 */ 

/*! This function has to set up timers for the time events that are required by the state machine. */
/*! 
	This function will be called for each time event that is relevant for a state when a state will be entered.
	\param evid An unique identifier of the event.
	\time_ms The time in milliseconds
	\periodic Indicates the the time event must be raised periodically until the timer is unset 
*/
extern void indM_set_timer(IndM* handle, const sc_eventid evid, const sc_integer time_ms, const sc_boolean periodic);

/*! This function has to unset timers for the time events that are required by the state machine. */
/*! 
	This function will be called for each time event that is relevant for a state when a state will be left.
	\param evid An unique identifier of the event.
*/
extern void indM_unset_timer(IndM* handle, const sc_eventid evid);



#ifdef __cplusplus
}
#endif 

#endif /* INDM_REQUIRED_H_ */
