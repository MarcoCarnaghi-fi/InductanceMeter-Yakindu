/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef INDM_H_
#define INDM_H_

#ifdef __cplusplus
extern "C" { 
#endif

/*!
* Forward declaration for the IndM state machine.
*/
typedef struct IndM IndM;

/*!
* Forward declaration of the data structure for the IndMIface interface scope.
*/
typedef struct IndMIface IndMIface;

/*!
* Forward declaration of the data structure for the IndMInternal interface scope.
*/
typedef struct IndMInternal IndMInternal;

/*!
* Forward declaration of the data structure for the IndMTimeEvents interface scope.
*/
typedef struct IndMTimeEvents IndMTimeEvents;

#ifdef __cplusplus
}
#endif

#include "..\src\sc_types.h"

#ifdef __cplusplus
extern "C" { 
#endif 

/*! \file Header of the state machine 'indM'.
*/

/*! Define number of states in the state enum */
#define INDM_STATE_COUNT 20

/*! Define dimension of the state configuration vector for orthogonal states. */
#define INDM_MAX_ORTHOGONAL_STATES 2
/*! Define maximum number of time events that can be active at once */
#define INDM_MAX_PARALLEL_TIME_EVENTS 2

/*! Define indices of states in the StateConfVector */
#define SCVI_INDM_R_MAIN_S_PORT_CONFIGURATION 0
#define SCVI_INDM_R_MAIN_S_RL_MEASUREMENT 0
#define SCVI_INDM_R_MAIN_S_RL_MEASUREMENT_R_RES_MED_S_WAIT 0
#define SCVI_INDM_R_MAIN_S_RL_MEASUREMENT_R_RES_MED_S_INITILIZATION 0
#define SCVI_INDM_R_MAIN_S_RL_MEASUREMENT_R_RES_MED_S_CONTROL_AND_RCALCULATION 0
#define SCVI_INDM_R_MAIN_S_RL_MEASUREMENT_R_RES_MED_S_CLOSE 0
#define SCVI_INDM_R_MAIN_S_TIME_GAIN_SETTING 0
#define SCVI_INDM_R_MAIN_S_TIME_GAIN_SETTING_R_TIME_GAIN_SET_S_SETTING 0
#define SCVI_INDM_R_MAIN_S_TIME_GAIN_SETTING_R_TIME_GAIN_SET_S_SAFE_CLOSE 0
#define SCVI_INDM_R_MAIN_S_TIME_GAIN_SETTING_R_TIME_GAIN_SET_S_NORMAL_CLOSE 0
#define SCVI_INDM_R_MAIN_S_IND_MEASUREMENT 0
#define SCVI_INDM_R_MAIN_S_IND_MEASUREMENT_R_MAIN_MEASUREMENT_S_WAIT_USER 0
#define SCVI_INDM_R_MAIN_S_IND_MEASUREMENT_R_MAIN_MEASUREMENT_S_WAIT_NEW_DATA 0
#define SCVI_INDM_R_MAIN_S_IND_MEASUREMENT_R_MAIN_MEASUREMENT_S_DATA_PROCESSING 0
#define SCVI_INDM_R_HANDLER_S_NULL_HANDLER 1
#define SCVI_INDM_R_HANDLER_S_TIME_GAIN_SET_HANDLER 1
#define SCVI_INDM_R_HANDLER_S_TIME_GAIN_SET_HANDLER_R_HANDLER_S_WAITING 1
#define SCVI_INDM_R_HANDLER_S_TIME_GAIN_SET_HANDLER_R_HANDLER_S_END_TIME 1
#define SCVI_INDM_R_HANDLER_S_RL_MEASUREMENT_HANDLER 1
#define SCVI_INDM_R_HANDLER_S_IND_MEASUREMENT_HANDLER 1

/*! Enumeration of all states */ 
typedef enum
{
	IndM_last_state,
	IndM_R_Main_s_Port_Configuration,
	IndM_R_Main_s_Rl_Measurement,
	IndM_R_Main_s_Rl_Measurement_R_Res_Med_s_Wait,
	IndM_R_Main_s_Rl_Measurement_R_Res_Med_s_Initilization,
	IndM_R_Main_s_Rl_Measurement_R_Res_Med_s_Control_and_RCalculation,
	IndM_R_Main_s_Rl_Measurement_R_Res_Med_s_Close,
	IndM_R_Main_s_Time_Gain_Setting,
	IndM_R_Main_s_Time_Gain_Setting_R_Time_Gain_set_s_Setting,
	IndM_R_Main_s_Time_Gain_Setting_R_Time_Gain_set_s_Safe_Close,
	IndM_R_Main_s_Time_Gain_Setting_R_Time_Gain_set_s_Normal_Close,
	IndM_R_Main_s_Ind_Measurement,
	IndM_R_Main_s_Ind_Measurement_R_Main_Measurement_s_Wait_User,
	IndM_R_Main_s_Ind_Measurement_R_Main_Measurement_s_Wait_New_data,
	IndM_R_Main_s_Ind_Measurement_R_Main_Measurement_s_Data_Processing,
	IndM_R_Handler_s_Null_Handler,
	IndM_R_Handler_s_Time_Gain_Set_Handler,
	IndM_R_Handler_s_Time_Gain_Set_Handler_r_handler_s_waiting,
	IndM_R_Handler_s_Time_Gain_Set_Handler_r_handler_s_end_time,
	IndM_R_Handler_s_Rl_Measurement_Handler,
	IndM_R_Handler_s_Ind_Measurement_Handler
} IndMStates;


/*! Type declaration of the data structure for the IndMIface interface scope. */
/*
struct IndMIface
{
	sc_boolean Conf_Ready;
	sc_real sp_Vref;
	sc_real sp_v_gate;
	sc_integer sp_data;
	sc_real sp_R;
	sc_integer runs;
	sc_boolean f_res_configured;
	sc_integer n_i;
	sc_integer n_f;
	sc_integer N_samples;
	sc_boolean f_ireach;
	sc_boolean WrongSetting;
	sc_boolean Gain_set;
	sc_boolean Full_buffer;
	sc_boolean Play_raised;
	sc_boolean Stop_raised;
};
*/
struct IndMIface
{
	sc_boolean Conf_Ready;
	sc_real* sp_Vref;
	sc_real* sp_v_gate;
	sc_integer* sp_data;
	sc_real* sp_R;
	sc_integer runs;
	sc_boolean f_res_configured;
	sc_integer n_i;
	sc_integer n_f;
	sc_integer N_samples;
	sc_boolean f_ireach;
	sc_boolean WrongSetting;
	sc_boolean Gain_set;
	sc_boolean Full_buffer;
	sc_boolean Play_raised;
	sc_boolean Stop_raised;
};

/*! Type declaration of the data structure for the IndMInternal interface scope. */
struct IndMInternal
{
	sc_boolean New_data_raised;
};



/*! Type declaration of the data structure for the IndMTimeEvents interface scope. */
struct IndMTimeEvents
{
	sc_boolean indM_R_Main_s_Time_Gain_Setting_R_Time_Gain_set_s_Setting_tev0_raised;
	sc_boolean indM_R_Handler_s_Time_Gain_Set_Handler_r_handler_s_waiting_tev0_raised;
	sc_boolean indM_R_Handler_s_Rl_Measurement_Handler_tev0_raised;
	sc_boolean indM_R_Handler_s_Ind_Measurement_Handler_tev0_raised;
};





typedef struct IndMIfaceEvBuf IndMIfaceEvBuf;
struct IndMIfaceEvBuf {
	sc_boolean Play_raised;
	sc_boolean Stop_raised;
};

typedef struct IndMInternalEvBuf IndMInternalEvBuf;
struct IndMInternalEvBuf {
	sc_boolean New_data_raised;
};

typedef struct IndMTimeEventsEvBuf IndMTimeEventsEvBuf;
struct IndMTimeEventsEvBuf {
	sc_boolean indM_R_Main_s_Time_Gain_Setting_R_Time_Gain_set_s_Setting_time_event_0_raised;
	sc_boolean indM_R_Handler_s_Time_Gain_Set_Handler_r_handler_s_waiting_time_event_0_raised;
	sc_boolean indM_R_Handler_s_Rl_Measurement_Handler_time_event_0_raised;
	sc_boolean indM_R_Handler_s_Ind_Measurement_Handler_time_event_0_raised;
};

typedef struct IndMEvBuf IndMEvBuf;
struct IndMEvBuf {
	IndMIfaceEvBuf iface;
	IndMInternalEvBuf internal;
	IndMTimeEventsEvBuf timeEvents;
};


/*! 
 * Type declaration of the data structure for the IndM state machine.
 * This data structure has to be allocated by the client code. 
 */
struct IndM
{
	IndMStates stateConfVector[INDM_MAX_ORTHOGONAL_STATES];
	sc_ushort stateConfVectorPosition; 
	IndMIface iface;
	IndMInternal internal;
	IndMTimeEvents timeEvents;
	IndMEvBuf current;
	sc_boolean isExecuting;
};



/*! Initializes the IndM state machine data structures. Must be called before first usage.*/
extern void indM_init(IndM* handle);


/*! Activates the state machine. */
extern void indM_enter(IndM* handle);

/*! Deactivates the state machine. */
extern void indM_exit(IndM* handle);

/*! Performs a 'run to completion' step. */
extern void indM_run_cycle(IndM* handle);



/*! Raises a time event. */
extern void indM_raise_time_event(IndM* handle, sc_eventid evid);

/*! Gets the value of the variable 'Conf_Ready' that is defined in the default interface scope. */ 
extern sc_boolean indM_get_conf_Ready(const IndM* handle);
/*! Sets the value of the variable 'Conf_Ready' that is defined in the default interface scope. */ 
extern void indM_set_conf_Ready(IndM* handle, sc_boolean value);


/*! Gets the value of the variable 'sp_Vref' that is defined in the default interface scope. */ 
//extern sc_real indM_get_sp_Vref(const IndM* handle);
extern sc_real* indM_get_sp_Vref(const IndM* handle);
/*! Sets the value of the variable 'sp_Vref' that is defined in the default interface scope. */ 
//extern void indM_set_sp_Vref(IndM* handle, sc_real value);
extern void indM_set_sp_Vref(IndM* handle, sc_real* value);

/*! Gets the value of the variable 'sp_v_gate' that is defined in the default interface scope. */ 
//extern sc_real indM_get_sp_v_gate(const IndM* handle);
extern sc_real* indM_get_sp_v_gate(const IndM* handle);
/*! Sets the value of the variable 'sp_v_gate' that is defined in the default interface scope. */ 
//extern void indM_set_sp_v_gate(IndM* handle, sc_real value);
extern void indM_set_sp_v_gate(IndM* handle, sc_real* value);

/*! Gets the value of the variable 'sp_data' that is defined in the default interface scope. */ 
//extern sc_integer indM_get_sp_data(const IndM* handle);
extern sc_integer* indM_get_sp_data(const IndM* handle);
/*! Sets the value of the variable 'sp_data' that is defined in the default interface scope. */ 
//extern void indM_set_sp_data(IndM* handle, sc_integer value);
extern void indM_set_sp_data(IndM* handle, sc_integer* value);


/*! Gets the value of the variable 'sp_R' that is defined in the default interface scope. */ 
//extern sc_real indM_get_sp_R(const IndM* handle);
extern sc_real* indM_get_sp_R(const IndM* handle);
/*! Sets the value of the variable 'sp_R' that is defined in the default interface scope. */ 
//extern void indM_set_sp_R(IndM* handle, sc_real value);
extern void indM_set_sp_R(IndM* handle, sc_real* value);

/*! Gets the value of the variable 'runs' that is defined in the default interface scope. */ 
extern sc_integer indM_get_runs(const IndM* handle);
/*! Sets the value of the variable 'runs' that is defined in the default interface scope. */ 
extern void indM_set_runs(IndM* handle, sc_integer value);
/*! Gets the value of the variable 'f_res_configured' that is defined in the default interface scope. */ 
extern sc_boolean indM_get_f_res_configured(const IndM* handle);
/*! Sets the value of the variable 'f_res_configured' that is defined in the default interface scope. */ 
extern void indM_set_f_res_configured(IndM* handle, sc_boolean value);
/*! Gets the value of the variable 'n_i' that is defined in the default interface scope. */ 
extern sc_integer indM_get_n_i(const IndM* handle);
/*! Sets the value of the variable 'n_i' that is defined in the default interface scope. */ 
extern void indM_set_n_i(IndM* handle, sc_integer value);
/*! Gets the value of the variable 'n_f' that is defined in the default interface scope. */ 
extern sc_integer indM_get_n_f(const IndM* handle);
/*! Sets the value of the variable 'n_f' that is defined in the default interface scope. */ 
extern void indM_set_n_f(IndM* handle, sc_integer value);
/*! Gets the value of the variable 'N_samples' that is defined in the default interface scope. */ 
extern sc_integer indM_get_n_samples(const IndM* handle);
/*! Sets the value of the variable 'N_samples' that is defined in the default interface scope. */ 
extern void indM_set_n_samples(IndM* handle, sc_integer value);
/*! Gets the value of the variable 'f_ireach' that is defined in the default interface scope. */ 
extern sc_boolean indM_get_f_ireach(const IndM* handle);
/*! Sets the value of the variable 'f_ireach' that is defined in the default interface scope. */ 
extern void indM_set_f_ireach(IndM* handle, sc_boolean value);
/*! Gets the value of the variable 'WrongSetting' that is defined in the default interface scope. */ 
extern sc_boolean indM_get_wrongSetting(const IndM* handle);
/*! Sets the value of the variable 'WrongSetting' that is defined in the default interface scope. */ 
extern void indM_set_wrongSetting(IndM* handle, sc_boolean value);
/*! Gets the value of the variable 'Gain_set' that is defined in the default interface scope. */ 
extern sc_boolean indM_get_gain_set(const IndM* handle);
/*! Sets the value of the variable 'Gain_set' that is defined in the default interface scope. */ 
extern void indM_set_gain_set(IndM* handle, sc_boolean value);
/*! Gets the value of the variable 'Full_buffer' that is defined in the default interface scope. */ 
extern sc_boolean indM_get_full_buffer(const IndM* handle);
/*! Sets the value of the variable 'Full_buffer' that is defined in the default interface scope. */ 
extern void indM_set_full_buffer(IndM* handle, sc_boolean value);
/*! Raises the in event 'Play' that is defined in the default interface scope. */ 
extern void indM_raise_play(IndM* handle);
/*! Raises the in event 'Stop' that is defined in the default interface scope. */ 
extern void indM_raise_stop(IndM* handle);

/*!
 * Checks whether the state machine is active (until 2.4.1 this method was used for states).
 * A state machine is active if it was entered. It is inactive if it has not been entered at all or if it has been exited.
 */
extern sc_boolean indM_is_active(const IndM* handle);

/*!
 * Checks if all active states are final. 
 * If there are no active states then the state machine is considered being inactive. In this case this method returns false.
 */
extern sc_boolean indM_is_final(const IndM* handle);

/*! Checks if the specified state is active (until 2.4.1 the used method for states was called isActive()). */
extern sc_boolean indM_is_state_active(const IndM* handle, IndMStates state);


#ifdef __cplusplus
}
#endif 

#endif /* INDM_H_ */
